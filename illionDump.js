/*
 * Module Imports
 * */
const fs = require('fs');
const path = require('path');
const mongoose = require('mongoose');
const Alert = mongoose.model('alert');
const AuditLog = mongoose.model('audit-log');
const CreditReport = mongoose.model('credit-report');
const Notification = mongoose.model('notification');
const Overdue = mongoose.model('overdue');
const Task = mongoose.model('task');
const Client = mongoose.model('client');
const Debtor = mongoose.model('debtor');
const Organization = mongoose.model('organization');
const DebtorDirector = mongoose.model('debtor-director');
const ClientDebtor = mongoose.model('client-debtor');
const Note = mongoose.model('note');
const Document = mongoose.model('document');
const Application = mongoose.model('application');
const moment = require('moment');
/*
 * Local Imports
 * */
const StaticData = require('./static-files/staticData.json');
const unProcessedApplicationIds = [];
let processedDebtors = fs.readFileSync(
  path.join(__dirname, 'processedDebtors20.json'),
);
processedDebtors = JSON.parse(processedDebtors.toString());

let unProcessedDebtors = fs.readFileSync(
  path.join(__dirname, 'unProcessedDebtors20.json'),
);
unProcessedDebtors = JSON.parse(unProcessedDebtors.toString());

let processedApplicationCount = 0;
const inputFilePath = [__dirname, '..', 'JSON-files', 'json_files_2021'];
const pdfFileInputPath = [
  __dirname,
  '..',
  'illion_dump_files',
  'output_files_2021',
  'pdf_files',
];
const pdfFileOutputPath = [
  __dirname,
  '..',
  'illion_dump_files',
  'output_files_2021',
  'processed_pdf_files_2021',
];
const userId = '6035f169f30c50fec2f70d7e';
const documentTypeId = '6155be6ec8e217314ac90fdc';
const validCountryArray = ['61', '64'];

/*const pdfFileNames = fs.readdirSync(path.join(...pdfFileInputPath));
console.log('pdfFileNames', pdfFileNames);
console.log('pdfFileNames length', pdfFileNames.length);*/

let applicationList = fs.readFileSync(
  path.join(...inputFilePath, 'application-list-filtered.json'),
);
applicationList = JSON.parse(applicationList.toString());
console.log('Total Application..........', Object.keys(applicationList).length);
const totalApplication = Object.keys(applicationList).length;

let companyList = fs.readFileSync(
  path.join(...inputFilePath, 'company-list.json'),
);
companyList = JSON.parse(companyList.toString());

let individualList = fs.readFileSync(
  path.join(...inputFilePath, 'individual-list.json'),
);
individualList = JSON.parse(individualList.toString());

let addressList = fs.readFileSync(
  path.join(...inputFilePath, 'address-list.json'),
);
addressList = JSON.parse(addressList.toString());

let questionAnswerList = fs.readFileSync(
  path.join(...inputFilePath, 'question-answer.json'),
);
questionAnswerList = JSON.parse(questionAnswerList.toString());

let notes = fs.readFileSync(path.join(...inputFilePath, 'notes.json'));
notes = JSON.parse(notes.toString());

let applicationApprovalDetails = fs.readFileSync(
  path.join(...inputFilePath, 'application-approval-details.json'),
);
applicationApprovalDetails = JSON.parse(applicationApprovalDetails.toString());

let applicationDetails = fs.readFileSync(
  path.join(...inputFilePath, 'application-details.json'),
);
applicationDetails = JSON.parse(applicationDetails.toString());

let updatedDebtorList = fs.readFileSync(
  path.join(__dirname, '..', 'oldPortalData.json'),
);
updatedDebtorList = JSON.parse(updatedDebtorList.toString());
console.log('updatedDebtorList', updatedDebtorList.length);

const allowedApplicationStatus = [
  'Approved',
  'Withdraw',
  'Refer',
  'Nil Approved',
  'Assess',
  'Approved Amount Cancelled',
  'Decline',
];
const allowedLimitTypes = ['Endorsed Limit', 'Monitored Account', 'Rescheck'];
const inValidABNs = ['111111111', '1111111111', '11111111111'];

/* Stores Merchant/Client Code - generated by RSS in Database */
const storeMerchantCode = async () => {
  try {
    let clientList = fs.readFileSync(
      path.join(...inputFilePath, 'client.json'),
    );
    clientList = clientList.toString();
    clientList = JSON.parse(clientList);

    const clients = await Client.find().lean();
    const promises = [];
    const remaining = [];
    clientList.forEach((i) => {
      const client = clients.find((client) => {
        return (
          i['Client Name'].toLowerCase().includes(client.name.toLowerCase()) ||
          client.name.toLowerCase().includes(i['Client Name'].toLowerCase())
        );
      });
      // console.log('found:', client);
      if (client) {
        // promises.push(
        //   Client.updateOne(
        //     { _id: client._id },
        //     { $unset: { merchantCode: 1 } },
        //   ),
        // );
        promises.push(
          Client.updateOne(
            { _id: client._id },
            { $addToSet: { merchantCode: i['Merchant Code'] } },
          ),
        );
      } else {
        remaining.push(i);
      }
    });
    await Promise.all(promises);
    console.log('remaining', remaining);
  } catch (e) {
    console.log('Error occurred', e);
  }
};

const entityTypes = ({ entityType }) => {
  try {
    switch (entityType) {
      case 'P/L':
        entityType = 'PROPRIETARY_LIMITED';
        break;
      case 'TRST':
        entityType = 'TRUST';
        break;
      case 'PTNR':
        entityType = 'PARTNERSHIP';
        break;
      case 'SLTR':
        entityType = 'SOLE_TRADER';
        break;
      case 'LTD':
        entityType = 'LIMITED';
        break;
      case 'CORP':
        entityType = 'CORPORATION';
        break;
      case 'INC':
        entityType = 'INCORPORATED';
        break;
      case 'BUS':
        entityType = 'BUSINESS';
        break;
      case 'GOVT':
        entityType = 'GOVERNMENT';
        break;
      case 'N/L':
        entityType = 'NO_LIABILITY';
        break;
      case 'PTY':
        entityType = 'PROPRIETARY';
        break;
      case 'R/B':
        entityType = 'REGISTERED_BODY';
        break;
    }
    return entityType;
  } catch (e) {
    console.log('Error occurred in replace entity type', e);
  }
};

const countryList = ({ country }) => {
  try {
    switch (country) {
      case '61':
        country = {
          code: 'AUS',
          name: 'Australia',
        };
        break;
      case '64':
        country = {
          code: 'NZL',
          name: 'New Zealand',
        };
        break;
    }
    return country;
  } catch (e) {
    console.log('Error occurred in get country name', e);
  }
};

const entityAddress = ({
  applicationId,
  activeApplicationIndex,
  entityType,
}) => {
  try {
    const address = {
      property:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'nm_property'
        ] || '',
      unitNumber:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'tx_number_unit'
        ] || '',
      streetNumber:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'tx_number_street'
        ] || '',
      streetName:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'nm_street'
        ] || '',
      streetType:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'cd_type_street'
        ] || '',
      suburb:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'nm_suburb'
        ] || '',
      state:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'cd_state'
        ] || '',
      postCode:
        addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
          'tx_postcode'
        ] || '',
    };
    let country = {
      code: 'AUS',
      name: 'Australia',
    };
    if (address?.streetType) {
      const streetType = StaticData.streetType.find((i) => {
        if (i._id === address.streetType.toUpperCase()) return i;
      });
      address.streetType =
        streetType && streetType.name
          ? streetType.name
          : address.streetType.toUpperCase();
    }
    if (
      addressList?.[applicationId]?.[activeApplicationIndex]?.[entityType]?.[
        'cd_country'
      ]
    ) {
      country = countryList({
        country:
          addressList[applicationId][activeApplicationIndex][entityType][
            'cd_country'
          ],
      });
    }
    if (country && entityType === 'Principal') {
      address.country = country;
    }
    return { address, country };
  } catch (e) {
    console.log('Error occurred in get entity address', e);
  }
};

const createDebtor = async ({
  applicationId,
  activeApplicationIndex,
  clientId,
}) => {
  try {
    const foundDebtor =
      companyList?.[applicationId]?.[activeApplicationIndex]?.['Principal'] ||
      null;
    if (foundDebtor) {
      const dbDebtor = await Debtor.findOne({
        entityName: foundDebtor['nm_legal'],
        abn: {
          $ne:
            companyList?.[applicationId]?.[activeApplicationIndex]?.[
              'Principal'
            ]?.['tx_abn'],
        },
      }).lean();
      if (!dbDebtor) {
        console.log('applicationId--------', applicationId);
        const excelDebtor = updatedDebtorList.find((i) => {
          if (i['Application ID'] === applicationId) {
            console.log('applicationId', applicationId);
            return i;
          }
        });
        console.log('Found debtor......', excelDebtor);
        if (
          excelDebtor &&
          (excelDebtor['Processed ABN'] || excelDebtor['Processed ACN']) &&
          ((excelDebtor['Country'] && excelDebtor['Country'] === 'Australia') ||
            excelDebtor['Country'] === 'New zealand')
        ) {
          const abn = excelDebtor['Processed ABN'];
          const acn = excelDebtor['Processed ACN'];
          const query = abn ? { abn: abn } : { acn: acn };
          const existingDebtor = await Debtor.findOne(query).lean();
          if (!existingDebtor) {
            const organization = await Organization.findOne({
              isDeleted: false,
            })
              .select('entityCount')
              .lean();
            const debtorAddress = await entityAddress({
              applicationId,
              activeApplicationIndex,
              entityType: 'Principal',
            });
            const debtorDetails = {
              debtorCode:
                'D' +
                (organization.entityCount.debtor + 1)
                  .toString()
                  .padStart(4, '0'),
              isActive: true,
              abn: excelDebtor['Processed ABN'],
              acn: excelDebtor['Processed ACN'],
              entityType: entityTypes({
                entityType: foundDebtor['cd_type_entity'],
              }),
              entityName: foundDebtor['nm_legal'],
              tradingName:
                foundDebtor['nm_trading'] ||
                excelDebtor['Principal Trading Name'],
              address: debtorAddress.address,
            };
            console.log('debtorDetails', debtorDetails);
            const debtor = await Debtor.create(debtorDetails);
            await Organization.updateOne(
              { isDeleted: false },
              { $inc: { 'entityCount.debtor': 1 } },
            );
            console.log('debtor', debtor);
            processedDebtors.push({
              applicationId: applicationId,
              reason: 'Debtor created',
              clientCode:
                applicationList[applicationId][activeApplicationIndex][
                  'id_merchant_submit'
                ],
              date:
                applicationList?.[applicationId]?.[activeApplicationIndex]?.[
                  'dt_modify'
                ],
              name: debtor.entityName,
              abn: debtor.abn,
              acn: debtor.acn,
              entityType: debtor.entityType,
              country: debtor.address?.country?.code || debtor.address?.country,
              debtorId: debtor._id,
            });
            return { debtor, isAllowed: true };
          } else {
            // Check for the Array
            processedDebtors.push({
              applicationId: applicationId,
              reason: 'Debtor found from database',
              clientCode:
                applicationList[applicationId][activeApplicationIndex][
                  'id_merchant_submit'
                ],
              date:
                applicationList?.[applicationId]?.[activeApplicationIndex]?.[
                  'dt_modify'
                ],
              name: excelDebtor?.entityName,
              abn: existingDebtor?.abn,
              acn: existingDebtor?.acn,
              entityType: excelDebtor.entityType,
              country:
                existingDebtor.address.country?.code ||
                existingDebtor.address.country,
              debtorId: excelDebtor._id,
            });
            return { debtor: existingDebtor, isAllowed: false };
          }
        } else {
          unProcessedDebtors.push({
            applicationId: applicationId,
            reason: !excelDebtor
              ? 'Debtor not found from excel'
              : !excelDebtor['Processed ABN'] && !excelDebtor['Processed ACN']
              ? 'No ABN or ACN found'
              : 'Country other than AUS/NZL', // Change message
            clientCode:
              applicationList[applicationId][activeApplicationIndex][
                'id_merchant_submit'
              ],
            date:
              applicationList?.[applicationId]?.[activeApplicationIndex]?.[
                'dt_modify'
              ],
          });
          return { debtor: null, isAllowed: false };
        }
      } else {
        processedDebtors.push({
          applicationId: applicationId,
          reason: 'Debtor found from database',
          clientCode:
            applicationList[applicationId][activeApplicationIndex][
              'id_merchant_submit'
            ],
          date:
            applicationList?.[applicationId]?.[activeApplicationIndex]?.[
              'dt_modify'
            ],
          name: dbDebtor?.entityName,
          abn: dbDebtor.abn,
          acn: dbDebtor.acn,
          entityType: dbDebtor.entityType,
          country: dbDebtor.address.country?.code || dbDebtor.address.country,
          debtorId: dbDebtor._id,
        });
        return { debtor: dbDebtor, isAllowed: false };
      }
      /*const abn =
        foundDebtor?.['tx_abn'] || foundDebtor?.['tx_company_nzbn'] || '';
      const acn =
        foundDebtor?.['tx_acn'] || foundDebtor?.['tx_company_no'] || '';
      const query = abn ? { abn: abn } : { acn: acn };
      const existingDebtor = await Debtor.findOne(query).lean();
      if (!existingDebtor) {
        const organization = await Organization.findOne({ isDeleted: false })
          .select('entityCount')
          .lean();
        const debtorAddress = await entityAddress({
          applicationId,
          activeApplicationIndex,
          entityType: 'Principal',
        });
        const debtorDetails = {
          debtorCode:
            'D' +
            (organization.entityCount.debtor + 1).toString().padStart(4, '0'),
          isActive: true,
          abn: abn,
          acn: acn,
          entityType: entityTypes({
            entityType: foundDebtor['cd_type_entity'],
          }),
          entityName: foundDebtor['nm_legal'],
          tradingName: foundDebtor['nm_trading'],
          address: debtorAddress.address,
        };
        // debtorDetails.address = debtorAddress.address;
        // console.log('debtorDetails',debtorDetails)
        const debtor = Debtor.create(debtorDetails);
        await Organization.updateOne(
          { isDeleted: false },
          { $inc: { 'entityCount.debtor': 1 } },
        );
        return debtor;
      }
      return existingDebtor;*/
    } else {
      unProcessedDebtors.push({
        applicationId: applicationId,
        reason: 'Debtor not found',
        clientCode:
          applicationList[applicationId][activeApplicationIndex][
            'id_merchant_submit'
          ],
        date:
          applicationList?.[applicationId]?.[activeApplicationIndex]?.[
            'dt_modify'
          ],
      });
      return { debtor: null, isAllowed: false };
    }
  } catch (e) {
    console.log('Error occurred in create debtor', e);
  }
};

const storeIndividual = async ({
  debtorId,
  applicationId,
  activeApplicationIndex,
  entityType,
}) => {
  try {
    const currentStakeholders =
      individualList[applicationId]?.[activeApplicationIndex];
    if (currentStakeholders && Object.keys(currentStakeholders).length !== 0) {
      let query;
      const promises = [];
      for (let key in currentStakeholders) {
        if (key.includes(entityType)) {
          query = {
            dateOfBirth: moment(
              currentStakeholders[key]['dt_dob'],
              'DD/MM/YYYY HH:mm:ss a',
            ).toISOString(),
            debtorId: debtorId,
            isDeleted: false,
            type: 'individual',
          };
          let existingStakeholder = await DebtorDirector.findOne(query).lean();
          if (!existingStakeholder) {
            //TODO add allowToCheckCreditHistory field
            const data = {
              type: 'individual',
              debtorId: debtorId,
              title: currentStakeholders[key]['cd_title'],
              firstName: currentStakeholders[key]['nm_firstname'],
              middleName: currentStakeholders[key]['nm_middlename'],
              lastName: currentStakeholders[key]['nm_surname'],
              dateOfBirth: moment(
                currentStakeholders[key]['dt_dob'],
                'DD/MM/YYYY HH:mm:ss a',
              ).toISOString(),
              residentialAddress: {},
            };
            const stakeholderAddress = await entityAddress({
              applicationId,
              activeApplicationIndex,
              entityType: key,
            });
            data.residentialAddress = stakeholderAddress?.address;
            data.country = stakeholderAddress?.country;
            promises.push(DebtorDirector.create(data));
          }
        }
      }
      await Promise.all(promises);
    }
  } catch (e) {
    console.log('Error occurred in store individual details', e);
  }
};

const storeCompany = async ({
  debtorId,
  applicationId,
  activeApplicationIndex,
  entityType,
}) => {
  try {
    const currentStakeholders =
      companyList[applicationId]?.[activeApplicationIndex];
    if (currentStakeholders && Object.keys(currentStakeholders).length !== 0) {
      let query;
      const promises = [];
      for (let key in currentStakeholders) {
        if (key.includes(entityType)) {
          const abn =
            currentStakeholders[key]?.['tx_abn'] ||
            currentStakeholders[key]?.['tx_company_nzbn'] ||
            '';
          const acn =
            currentStakeholders[key]?.['tx_acn'] ||
            currentStakeholders[key]?.['tx_company_no'] ||
            '';

          query = abn
            ? {
                abn: abn,
                debtorId: debtorId,
                isDeleted: false,
                type: 'company',
              }
            : {
                acn: acn,
                debtorId: debtorId,
                isDeleted: false,
                type: 'company',
              };

          const existingStakeholder = await DebtorDirector.findOne(
            query,
          ).lean();
          if (!existingStakeholder) {
            //TODO add allowToCheckCreditHistory field
            const data = {
              type: 'company',
              debtorId: debtorId,
              abn: abn,
              acn: acn,
              entityType: entityTypes({
                entityType: currentStakeholders[key]['cd_type_entity'],
              }),
              entityName: currentStakeholders[key]['nm_legal'],
              tradingName: currentStakeholders[key]['nm_trading'],
            };
            const stakeholderAddress = await entityAddress({
              applicationId,
              activeApplicationIndex,
              entityType: key,
            });
            data.residentialAddress = stakeholderAddress?.address;
            data.country = stakeholderAddress?.country;
            promises.push(DebtorDirector.create(data));
          }
        }
      }
      await Promise.all(promises);
    }
  } catch (e) {
    console.log('Error occurred in store company details', e);
  }
};

const createCreditLimit = async ({ debtorId, clientId, update, isAllowed }) => {
  try {
    if (isAllowed) {
      await ClientDebtor.updateOne(
        { clientId: clientId, debtorId: debtorId },
        update,
        { upsert: true },
      );
    }
    const clientDebtor = await ClientDebtor.findOne({
      clientId: clientId,
      debtorId: debtorId,
    }).lean();
    return clientDebtor;
  } catch (e) {
    console.log('Error occurred in create credit limit', e);
  }
};

const createNotes = async ({
  applicationNumber,
  activeApplicationIndex,
  applicationId,
}) => {
  try {
    const currentNotes = notes?.[applicationNumber]?.[activeApplicationIndex];
    const promises = [];
    for (let key in currentNotes) {
      // promises.push(
      //   Note.create({
      //     noteFor: 'application',
      //     entityId: applicationId,
      //     description:
      //       currentNotes[key]['tx_subject'] +
      //       '\n' +
      //       currentNotes[key]['tx_note'],
      //     isPublic: true,
      //   }),
      // );
      promises.push(
        Note.updateOne(
          {
            noteFor: 'application',
            entityId: applicationId,
            description:
              currentNotes[key]['tx_subject'] +
              '\n' +
              currentNotes[key]['tx_note'],
            isPublic: false,
          },
          {
            noteFor: 'application',
            entityId: applicationId,
            description:
              currentNotes[key]['tx_subject'] +
              '\n' +
              currentNotes[key]['tx_note'],
            isPublic: false,
            createdByType: 'user',
            createdById: userId,
          },
          { upsert: true, setDefaultsOnInsert: true },
        ),
      );
    }
    await Promise.all(promises);
  } catch (e) {
    console.log('Error occurred in create notes', e);
  }
};

const createDocuments = async ({ applicationNumber, applicationId }) => {
  try {
    const currentDocuments = pdfFileNames.filter((fileName) =>
      fileName.includes(applicationNumber + '_'),
    );
    const promises = [];
    currentDocuments.forEach((document) => {
      promises.push(
        Document.create({
          keyPath: 'documents/application/' + document,
          originalFileName: document,
          uploadByType: 'user',
          uploadById: userId,
          entityType: 'application',
          entityRefId: applicationId,
          isPublic: false,
          mimeType: 'application/pdf',
          documentTypeId,
        }),
      );
      fs.copyFileSync(
        path.join(...pdfFileInputPath, document),
        path.join(...pdfFileOutputPath, document),
      );
    });
    await Promise.all(promises);
  } catch (e) {
    console.log('Error occurred in create documents', e);
  }
};

// TODO change the Application status as per the Excel File
const mapApplicationStatus = ({ status }) => {
  try {
    switch (status) {
      case 'Approved':
        status = 'APPROVED';
        break;
      case 'Withdraw':
        status = 'WITHDRAWN';
        break;
      case 'Stored':
        status = '';
        break;
      case 'Refer':
        status = 'PENDING_INSURER_REVIEW';
        break;
      case 'Nil Approved':
        status = 'DECLINED';
        break;
      case 'New App with Nil Amount':
        status = '';
        break;
      case 'Error':
        status = '';
        break;
      case 'Assess':
        status = 'REVIEW_APPLICATION';
        break;
      case 'Approved Amount Cancelled':
        status = 'CANCELLED';
        break;
      case 'Decline':
        status = 'DECLINED';
        break;
      case 'Cancelled':
        status = '';
        break;
    }
    return status;
  } catch (e) {
    console.log('Error occurred in get application status', e);
  }
};

const getLimitType = (limitType) => {
  try {
    switch (limitType) {
      case 'Endorsed Limit':
        limitType = 'ENDORSED';
        break;
      case 'Monitored Account':
      case 'Rescheck':
        limitType = 'CREDIT_CHECK';
        break;
    }
    return limitType;
  } catch (e) {
    console.log('Error occurred in get application limitType', e);
  }
};

const importApplications = async () => {
  try {
    let count = 0;
    for (let key in applicationList) {
      const activeApplicationIndex = Math.max(
        ...Object.keys(applicationList[key]),
      );
      if (
        activeApplicationIndex &&
        applicationList[key][activeApplicationIndex]
      ) {
        const activeApplicationDetails =
          applicationDetails?.[key]?.[activeApplicationIndex];
        if (
          validCountryArray.includes(
            applicationList[key][activeApplicationIndex]['cd_country'],
          )
        ) {
          if (
            allowedApplicationStatus.indexOf(
              applicationList[key][activeApplicationIndex]['cd_status'],
            ) !== -1 &&
            allowedLimitTypes.indexOf(
              activeApplicationDetails['tx_tcr_product'],
            ) !== -1
          ) {
            let application = await Application.findOne({
              applicationId: key,
            });
            if (!application) {
              application = new Application();
            }
            const client = await Client.findOne({
              merchantCode: {
                $in: [
                  applicationList[key][activeApplicationIndex][
                    'id_merchant_submit'
                  ],
                ],
              },
            }).lean();
            if (!client) {
              unProcessedApplicationIds.push({
                applicationId: key,
                reason: 'Client not found',
                clientCode:
                  applicationList[key][activeApplicationIndex][
                    'id_merchant_submit'
                  ],
                applicationDate:
                  applicationList[key][activeApplicationIndex]?.['dt_modify'],
              });
            } else {
              const debtor = await createDebtor({
                applicationId: key,
                activeApplicationIndex,
              });
              if (debtor) {
                if (
                  debtor?.entityType === 'TRUST' ||
                  debtor?.entityType === 'PARTNERSHIP'
                ) {
                  await Promise.all([
                    await storeIndividual({
                      debtorId: debtor._id,
                      entityType: 'CoBorrower',
                      activeApplicationIndex,
                      applicationId: key,
                    }),
                    await storeCompany({
                      debtorId: debtor._id,
                      entityType: 'CoBorrower',
                      activeApplicationIndex,
                      applicationId: key,
                    }),
                  ]);
                } else if (debtor?.entityType === 'SOLE_TRADER') {
                  await storeIndividual({
                    debtorId: debtor._id,
                    entityType: 'CoBorrower',
                    activeApplicationIndex,
                    applicationId: key,
                  });
                }

                const approvedApplicationDetails =
                  applicationApprovalDetails?.[key]?.[activeApplicationIndex];
                const applicationQuestions =
                  questionAnswerList?.[key]?.[activeApplicationIndex];

                application.applicationId = key;
                application.clientId = client._id;
                application.debtorId = debtor._id;
                application.status = mapApplicationStatus({
                  status:
                    applicationList[key][activeApplicationIndex]['cd_status'],
                });
                application.isAutoApproved = false;
                application.isExtendedPaymentTerms =
                  applicationQuestions?.['extended_policy'] === '1';
                application.isPassedOverdueAmount =
                  applicationQuestions?.['extended_overdue'] === '1';
                application.creditLimit = approvedApplicationDetails?.[
                  'am_requsted'
                ]
                  ? parseInt(approvedApplicationDetails['am_requsted'])
                  : 0;
                application.acceptedAmount = approvedApplicationDetails?.[
                  'am_granted'
                ]
                  ? parseInt(approvedApplicationDetails['am_granted'])
                  : 0;
                application.clientReference =
                  approvedApplicationDetails?.['no_acc_reference'] || '';
                application.comments =
                  activeApplicationDetails?.['tx_comments'] || '';
                application.requestDate = approvedApplicationDetails?.[
                  'dt_submit'
                ]
                  ? moment(
                      approvedApplicationDetails?.['dt_submit'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : null;
                application.approvalOrDecliningDate = approvedApplicationDetails?.[
                  'dt_effective'
                ]
                  ? moment(
                      approvedApplicationDetails?.['dt_effective'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : approvedApplicationDetails?.['dt_approved']
                  ? moment(
                      approvedApplicationDetails?.['dt_approved'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : null;
                application.isEndorsedLimit =
                  activeApplicationDetails?.['tx_tcr_product'] ===
                  'Endorsed Limit';
                application.limitType = getLimitType(
                  activeApplicationDetails?.['tx_tcr_product'],
                );
                await createNotes({
                  applicationId: application._id,
                  activeApplicationIndex,
                  applicationNumber: key,
                });
                await createDocuments({
                  applicationId: application._id,
                  applicationNumber: key,
                });
                const inActiveStatus = ['CANCELLED', 'WITHDRAWN'];
                const update = {
                  clientId: client._id,
                  debtorId: debtor._id,
                  isActive: !inActiveStatus.includes(application.status),
                  isFromOldSystem: true,
                  isEndorsedLimit: application.isEndorsedLimit,
                  creditLimit: application.acceptedAmount,
                  activeApplicationId: application._id,
                };
                const clientDebtor = await createCreditLimit({
                  clientId: client._id,
                  debtorId: debtor._id,
                  update,
                });
                application.clientDebtorId = clientDebtor?._id;
                // TODO Application date change

                application.createdAt = moment(
                  applicationList[key][activeApplicationIndex]['dt_request'],
                  'DD/MM/YYYY HH:mm:ss a',
                ).toISOString();
                await application.save();
                // TODO Documents Helper function to Store Documents in DB + CP in other file

                if (approvedApplicationDetails?.['dt_review']) {
                  await Debtor.updateOne(
                    { _id: debtor._id },
                    {
                      reviewDate: moment(
                        approvedApplicationDetails['dt_review'],
                        'DD/MM/YYYY HH:mm:ss a',
                      ).toISOString(),
                    },
                  );
                }
                processedApplicationCount++;
                console.log(
                  'Application generated successfully.....',
                  key,
                  count + '/' + totalApplication,
                );
              }
            }
            /* else {
            // TODO remove if else
            console.log('Application skipped.........');
          }*/
          } else {
            console.log(
              'Skipping Application due to unwanted status or limit type',
              key,
              count + '/' + totalApplication,
            );
            unProcessedApplicationIds.push({
              applicationId: key,
              reason: 'unwanted Status or Limit Type',
              clientCode:
                applicationList[key][activeApplicationIndex][
                  'id_merchant_submit'
                ],
              applicationDate:
                applicationList[key][activeApplicationIndex]?.['dt_modify'],
            });
          }
        }
      }
      count += 1;
    }
    console.log('unProcessedApplicationIds', unProcessedApplicationIds);
    fs.writeFileSync(
      'unProcessedApplicationIds.json',
      JSON.stringify(unProcessedApplicationIds),
    );
    console.log(
      'Processed Application Count..............',
      processedApplicationCount,
    );
  } catch (e) {
    console.log('Error occurred in import applications', e);
  }
};

const resetClientDebtorCode = async () => {
  try {
    let promiseArr = [];
    promiseArr.push(Client.find({}).sort({ _id: 1 }));
    promiseArr.push(Debtor.find({}).sort({ _id: 1 }));
    promiseArr.push(Organization.findOne({ isDeleted: false }));
    let [clients, debtors, organization] = await Promise.all(promiseArr);
    promiseArr = [];
    let i;
    for (i = 0; i < clients.length; i += 1) {
      clients[i].clientCode = 'C' + (i + 1).toString().padStart(4, '0');
      promiseArr.push(clients[i].save());
    }
    organization.entityCount.client = i;
    for (i = 0; i < debtors.length; i += 1) {
      debtors[i].debtorCode = 'D' + (i + 1).toString().padStart(4, '0');
      promiseArr.push(debtors[i].save());
    }
    organization.entityCount.debtor = i;
    promiseArr.push(organization.save());
    await Promise.all(promiseArr);
  } catch (e) {
    console.log('Error in resetting Client and Debtor Code', e.message || e);
  }
};

const removeRedundantDebtors = async () => {
  try {
    const debtorPipeline = [
      {
        $match: {
          abn: {
            $exists: true,
            $ne: null,
          },
        },
      },
      {
        $group: {
          _id: '$abn',
          debtors: {
            $push: '$$ROOT',
          },
        },
      },
      {
        $project: {
          debtorsLength: {
            $size: '$debtors',
          },
          debtors: '$debtors',
        },
      },
      {
        $match: {
          debtorsLength: {
            $gt: 1,
          },
        },
      },
    ];
    const debtorGroups = await Debtor.aggregate(debtorPipeline);
    const deletedDetails = [];
    console.log('Received Debtor Groups,processing them...');
    // console.log(JSON.stringify(debtorGroups, null, 3));
    for (let i = 0; i < debtorGroups.length; i += 1) {
      const debtorIds = debtorGroups[i].debtors.map((d) => d._id);
      console.log(JSON.stringify(debtorIds, null, 3));
      const primaryDebtorId = debtorIds.shift();
      if (primaryDebtorId && debtorIds.length > 0) {
        const promiseArr = [];
        promiseArr.push(
          Alert.updateMany(
            { entityType: 'debtor', entityId: { $in: debtorIds } },
            { $set: { entityId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Application.updateMany(
            { debtorId: { $in: debtorIds } },
            { $set: { debtorId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          AuditLog.updateMany(
            { entityType: 'debtor', entityRefId: { $in: debtorIds } },
            { $set: { entityRefId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          ClientDebtor.updateMany(
            { debtorId: { $in: debtorIds } },
            { $set: { debtorId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          CreditReport.updateMany(
            { entityType: 'debtor', entityId: { $in: debtorIds } },
            { $set: { entityId: primaryDebtorId } },
          ),
        );
        promiseArr.push(Debtor.deleteMany({ _id: { $in: debtorIds } }));
        promiseArr.push(
          DebtorDirector.updateMany(
            { debtorId: { $in: debtorIds } },
            { $set: { debtorId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Document.updateMany(
            { entityType: 'debtor', entityRefId: { $in: debtorIds } },
            { $set: { entityRefId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Note.updateMany(
            { entityType: 'debtor', entityId: { $in: debtorIds } },
            { $set: { entityId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Notification.updateMany(
            { entityType: 'debtor', entityId: { $in: debtorIds } },
            { $set: { entityId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Overdue.updateMany(
            { debtorId: { $in: debtorIds } },
            { $set: { debtorId: primaryDebtorId } },
          ),
        );
        promiseArr.push(
          Task.updateMany(
            { entityType: 'debtor', entityId: { $in: debtorIds } },
            { $set: { entityId: primaryDebtorId } },
          ),
        );
        let results = await Promise.all(promiseArr);
        deletedDetails.push({
          primaryDebtorId,
          otherDebtorIds: debtorIds,
          results,
        });
      }
    }
    fs.writeFileSync(
      'delete-debtor-results.json',
      JSON.stringify(deletedDetails),
    );
    console.log(
      'Successfully deleted redundant debtors and supportive DB documents',
    );
  } catch (e) {
    console.log('Error in resetting Client and Debtor Code', e.message || e);
  }
};

// TODO Add arrays to collect, ABN< ACN< NZBN and NCN
const updateApplicationsAndDebtors = async () => {
  try {
    let count = 0;
    for (let key in applicationList) {
      const activeApplicationIndex = Math.max(
        ...Object.keys(applicationList[key]),
      );
      if (
        activeApplicationIndex &&
        applicationList[key][activeApplicationIndex]
      ) {
        const activeApplicationDetails =
          applicationDetails?.[key]?.[activeApplicationIndex];
        if (
          validCountryArray.includes(
            applicationList[key][activeApplicationIndex]['cd_country'],
          ) &&
          inValidABNs.indexOf(
            companyList?.[key]?.[activeApplicationIndex]?.['Principal']?.[
              'tx_abn'
            ],
          ) !== -1
        ) {
          if (
            allowedApplicationStatus.indexOf(
              applicationList[key][activeApplicationIndex]['cd_status'],
            ) !== -1 &&
            allowedLimitTypes.indexOf(
              activeApplicationDetails['tx_tcr_product'],
            ) !== -1
          ) {
            let application = await Application.findOne({
              applicationId: key,
            });
            if (!application) {
              application = new Application();
            }
            const client = await Client.findOne({
              merchantCode: {
                $in: [
                  applicationList[key][activeApplicationIndex][
                    'id_merchant_submit'
                  ],
                ],
              },
            }).lean();
            if (!client) {
              unProcessedApplicationIds.push({
                applicationId: key,
                reason: 'Client not found',
                clientCode:
                  applicationList[key][activeApplicationIndex][
                    'id_merchant_submit'
                  ],
                applicationDate:
                  applicationList[key][activeApplicationIndex]?.['dt_modify'],
              });
            } else {
              let { debtor, isAllowed } = await createDebtor({
                applicationId: key,
                activeApplicationIndex,
                clientId: client._id,
              });
              if (debtor) {
                const creditLimit = await ClientDebtor.findOne({
                  clientId: client._id,
                  debtorId: debtor._id,
                  isActive: true,
                  creditLimit: { $exists: true, $ne: 0 },
                }).lean();
                if (!creditLimit) {
                  isAllowed = true;
                }
                if (
                  debtor?.entityType === 'TRUST' ||
                  debtor?.entityType === 'PARTNERSHIP'
                ) {
                  await Promise.all([
                    await storeIndividual({
                      debtorId: debtor._id,
                      entityType: 'CoBorrower',
                      activeApplicationIndex,
                      applicationId: key,
                    }),
                    await storeCompany({
                      debtorId: debtor._id,
                      entityType: 'CoBorrower',
                      activeApplicationIndex,
                      applicationId: key,
                    }),
                  ]);
                } else if (debtor?.entityType === 'SOLE_TRADER') {
                  await storeIndividual({
                    debtorId: debtor._id,
                    entityType: 'CoBorrower',
                    activeApplicationIndex,
                    applicationId: key,
                  });
                }

                const approvedApplicationDetails =
                  applicationApprovalDetails?.[key]?.[activeApplicationIndex];
                const applicationQuestions =
                  questionAnswerList?.[key]?.[activeApplicationIndex];

                application.applicationId = key;
                application.clientId = client._id;
                application.debtorId = debtor._id;
                application.status = mapApplicationStatus({
                  status:
                    applicationList[key][activeApplicationIndex]['cd_status'],
                });
                application.isAutoApproved = false;
                application.isExtendedPaymentTerms =
                  applicationQuestions?.['extended_policy'] === '1';
                application.isPassedOverdueAmount =
                  applicationQuestions?.['extended_overdue'] === '1';
                application.creditLimit = approvedApplicationDetails?.[
                  'am_requsted'
                ]
                  ? parseInt(approvedApplicationDetails['am_requsted'])
                  : 0;
                application.acceptedAmount = approvedApplicationDetails?.[
                  'am_granted'
                ]
                  ? parseInt(approvedApplicationDetails['am_granted'])
                  : 0;
                application.clientReference =
                  approvedApplicationDetails?.['no_acc_reference'] || '';
                application.comments =
                  activeApplicationDetails?.['tx_comments'] || '';
                application.requestDate = approvedApplicationDetails?.[
                  'dt_submit'
                ]
                  ? moment(
                      approvedApplicationDetails?.['dt_submit'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : null;
                application.approvalOrDecliningDate = approvedApplicationDetails?.[
                  'dt_effective'
                ]
                  ? moment(
                      approvedApplicationDetails?.['dt_effective'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : approvedApplicationDetails?.['dt_approved']
                  ? moment(
                      approvedApplicationDetails?.['dt_approved'],
                      'DD/MM/YYYY HH:mm:ss a',
                    ).toISOString()
                  : null;
                application.isEndorsedLimit =
                  activeApplicationDetails?.['tx_tcr_product'] ===
                  'Endorsed Limit';
                application.limitType = getLimitType(
                  activeApplicationDetails?.['tx_tcr_product'],
                );
                /* await createNotes({
                  applicationId: application._id,
                  activeApplicationIndex,
                  applicationNumber: key,
                });
                await createDocuments({
                  applicationId: application._id,
                  applicationNumber: key,
                });*/
                const inActiveStatus = ['CANCELLED', 'WITHDRAWN'];
                const update = {
                  clientId: client._id,
                  debtorId: debtor._id,
                  isActive: !inActiveStatus.includes(application.status),
                  isFromOldSystem: true,
                  isEndorsedLimit: application.isEndorsedLimit,
                  creditLimit: application.acceptedAmount,
                  activeApplicationId: application._id,
                };
                const clientDebtor = await createCreditLimit({
                  clientId: client._id,
                  debtorId: debtor._id,
                  update,
                  isAllowed,
                });
                application.clientDebtorId = clientDebtor?._id;
                application.createdAt = moment(
                  applicationList[key][activeApplicationIndex]['dt_request'],
                  'DD/MM/YYYY HH:mm:ss a',
                ).toISOString();
                await application.save();
                // TODO Documents Helper function to Store Documents in DB + CP in other file

                if (approvedApplicationDetails?.['dt_review']) {
                  await Debtor.updateOne(
                    { _id: debtor._id },
                    {
                      reviewDate: moment(
                        approvedApplicationDetails['dt_review'],
                        'DD/MM/YYYY HH:mm:ss a',
                      ).toISOString(),
                    },
                  );
                }
                processedApplicationCount++;
                console.log(
                  'Application generated successfully.....',
                  key,
                  count + '/' + totalApplication,
                );
              }
            }
            /* else {
            // TODO remove if else
            console.log('Application skipped.........');
          }*/
          } else {
            console.log(
              'Skipping Application due to unwanted status or limit type',
              key,
              count + '/' + totalApplication,
            );
            unProcessedApplicationIds.push({
              applicationId: key,
              reason: 'unwanted Status or Limit Type',
              clientCode:
                applicationList[key][activeApplicationIndex][
                  'id_merchant_submit'
                ],
              applicationDate:
                applicationList[key][activeApplicationIndex]?.['dt_modify'],
            });
          }
        }
      }
      count += 1;
    }
    console.log('unProcessedApplicationIds', unProcessedApplicationIds);
    fs.writeFileSync(
      'unProcessedDebtors21.json',
      JSON.stringify(unProcessedDebtors),
    );
    fs.writeFileSync(
      'processedDebtors21.json',
      JSON.stringify(processedDebtors),
    );
    console.log(
      'Processed Application Count..............',
      processedApplicationCount,
    );
  } catch (e) {
    console.log('Error occurred in import applications', e);
  }
};

const main = async () => {
  console.log('Executing the DUMP Script at', new Date());
  // await resetClientDebtorCode();
  // await storeMerchantCode();
  // await importApplications();
  // await removeRedundantDebtors();
  // fs.writeFileSync('same-debtors.json', JSON.stringify(sameDebtors));
  // console.log('Successfully executed the DUMP Script', JSON.stringify(sameDebtorABN));
  console.log('Successfully executed the DUMP Script at', new Date());
};

main();

module.exports = {
  storeMerchantCode,
  importApplications,
  updateApplicationsAndDebtors,
};
